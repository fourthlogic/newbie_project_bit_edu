int _MAX = 0;
void BP(vector<int>& v, int depth) {
    if (v.size() == depth) {
        int ans = 0;
        for (int i = 0; i < v.size() - 1; i++)
            ans += abs(v[i] - v[i + 1]);

        if (ans > _MAX)
            _MAX = ans;
        return;
    }
    for (int i = depth; i < v.size(); i++) {
        swap(v[i], v[depth]);
        BP(v, depth + 1);
        swap(v[i], v[depth]);
    }
}

// 
void CircleDection::Rotation_Run()
{
    cvtColor(this->src, this->result, COLOR_GRAY2BGR);
    cornerPts.clear(); // 외곽 3점 좌표 값
    vCirCenters.clear(); // Vertical의 중심 좌표들의 값 
    hCirCenters.clear(); // Horizontal의 중심 좌표들의 값 
    vertexPts.clear();   // 최외곽 ROI Vertex Points
    CirCenters.clear(); // 중심값  초기화
    LinePoints.clear(); // 직선점 초기화
    GetCornerPoints(); // 3점 좌표 추출

    double theta = atan2((this->cornerPts[0].x - this->cornerPts[0].x), (1000 - this->cornerPts[0].y))
        - atan2((this->cornerPts[1].x - this->cornerPts[0].x), this->cornerPts[1].y - this->cornerPts[0].y);
    this->rotation<uchar>(this->src, Rotate, -theta, this->cornerPts[0]);


    //this->src = Rotate;
    //this->Run();
    //circle(result, cornerPts[0], 3, Scalar(255, 255, 255), 3);
    //imshow("result", this->result);
    //imshow("Rotate", Rotate);
    
}


// 로테이트 
template <typename T>
double CircleDection::Bilinear_Value(Mat& src, Point2d pt)
{
    if (pt.x >= src.cols - 1) pt.x--;
    if (pt.y >= src.rows - 1) pt.y--;
    int h = src.rows;
    int w = src.cols;
    Point Index((int)pt.x, (int)pt.y);
    T* ptr = (T*)src.data;

    double A = ptr[Index.y * w + Index.x];
    double B = ptr[(Index.y + 1) * w + Index.x];
    double C = ptr[Index.y * w + Index.x + 1];
    double D = ptr[(Index.y + 1) * w + Index.x + 1];

    double alpha = pt.y - Index.y;
    double beta = pt.x - Index.x;
    double M1 = A + alpha * (B - A);
    double M2 = C + alpha * (D - C);
    double P = M1 + beta * (M2 - M1);

    return P;
}

template <typename T>
void CircleDection::rotation(Mat src, Mat& dst, double theta, Point pt, int m_height, int m_width)
{
    double sin_value = sin(theta);
    double cos_value = cos(theta);

    int h = src.rows - m_height;
    int w = src.cols;

    Rect rect(Point(0, 0), src.size());
    dst = Mat(src.size(), src.type(), Scalar(0));
    T* ptr;

    Point2d target;
    for (int i = 0; i < h; i++)
    {
        ptr = (T*)dst.ptr<T>(i + m_height);
        for (int j = m_width; j < w; j++)
        {
            // 좌표 이동전 -을 해서 이동시키기고 복원하려고
            int jj = j - pt.x;
            int ii = i - pt.y;

            // 회전 좌표계산 후 + 좌표이동
            target.x = jj * cos_value + ii * sin_value + pt.x;
            target.y = -jj * sin_value + ii * cos_value + pt.y; // 

            if (rect.contains(target))
                ptr[j - m_width] = Bilinear_Value<T>(src, target);
        }
    }
}